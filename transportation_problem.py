# -*- coding: utf-8 -*-
"""Transportation_problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C3AFSN4jtFp8jLiN6N3kFG0NigLBf36t
"""

# NorthWest Corner Method, 2. Least Cost Method, 3. Vogel's Approximation Method

import numpy as np

def vogels_approximation_method(cost_matrix, supply, demand):
    allocation = np.zeros_like(cost_matrix)
    supply_left = supply.copy()
    demand_left = demand.copy()

    while np.any(supply_left > 0) and np.any(demand_left > 0):
        # Calculate row and column penalties
        row_penalties = calculate_penalties(cost_matrix, axis=1)
        col_penalties = calculate_penalties(cost_matrix, axis=0)

        # Find the highest penalty; prefer rows over columns in case of a tie
        if max(row_penalties.max(), col_penalties.max()) == row_penalties.max():
            i = row_penalties.argmax()
            sorted_costs_indices = cost_matrix[i, :].argsort()
            j = sorted_costs_indices[0] if demand_left[sorted_costs_indices[0]] > 0 else sorted_costs_indices[1]
        else:
            j = col_penalties.argmax()
            sorted_costs_indices = cost_matrix[:, j].argsort()
            i = sorted_costs_indices[0] if supply_left[sorted_costs_indices[0]] > 0 else sorted_costs_indices[1]

        # Allocate as much as possible to the cell with the highest penalty
        allocation_amount = min(supply_left[i], demand_left[j])
        allocation[i, j] = allocation_amount
        supply_left[i] -= allocation_amount
        demand_left[j] -= allocation_amount

        # Update the cost matrix to prevent further allocation to fulfilled demands or supplies
        if supply_left[i] == 0:
            cost_matrix[i, :] = np.inf
        if demand_left[j] == 0:
            cost_matrix[:, j] = np.inf

    return allocation

def least_cost_method(cost, supply, demand):

    allocation = np.zeros_like(cost)

    supply_left = supply.copy()
    demand_left = demand.copy()

    while np.any(supply_left > 0) and np.any(demand_left > 0):
        # Find the minimum cost cell not yet allocated
        # Mask already allocated cells with a high value
        cost_masked = np.where(allocation == 0, cost, np.max(cost) + 1)
        i, j = divmod(cost_masked.argmin(), cost.shape[1])

        # Allocate as much as possible to the minimum cost cell
        allocation_amount = min(supply_left[i], demand_left[j])
        allocation[i, j] = allocation_amount

        # Adjust supply and demand
        supply_left[i] -= allocation_amount
        demand_left[j] -= allocation_amount

        # If supply or demand is met, increase the corresponding costs to prevent further allocation
        if supply_left[i] == 0:
            cost[i, :] = np.max(cost) + 1
        if demand_left[j] == 0:
            cost[:, j] = np.max(cost) + 1

    return allocation

def northwest_corner(cost_matrix, supply, demand):
    m, n = cost_matrix.shape
    allocation = np.zeros((m, n))

    i, j = 0, 0

    while i < m and j < n:
        quantity = min(supply[i], demand[j])
        allocation[i, j] = quantity
        supply[i] -= quantity
        demand[j] -= quantity

        if supply[i] == 0:
            i += 1
        else:
            j += 1

    return allocation

def calculate_total_cost(allocation, cost_matrix):
    print( cost_matrix)
    total_cost = (allocation * cost_matrix).sum()

    return total_cost

if __name__ == "__main__":
  cost_matrix = np.array([
      [3, 1, 7, 4],
      [2, 6, 5, 9],
      [8,3, 3, 2]
  ])

  supply = np.array([300, 400, 500])
  demand = np.array([250, 350, 400, 200])

  allocation = least_cost_method(cost_matrix, supply, demand)
  min_cost=calculate_total_cost(allocation, cost_matrix)
  # Print the results
  print("Allocation Matrix:")
  print(allocation)
  print("Minimum cost = ", min_cost)